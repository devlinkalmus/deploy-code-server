/**
 * GitHub API MCP
 * Sample Modular Compute Pod for GitHub API integration
 */

export interface GitHubMCPConfig {
  apiKey?: string;
  baseUrl: string;
  rateLimit: {
    requestsPerHour: number;
    currentUsage: number;
  };
}

export class GitHubMCP {
  private config: GitHubMCPConfig;
  private lastHealthCheck: Date;

  constructor(config: GitHubMCPConfig) {
    this.config = config;
    this.lastHealthCheck = new Date();
  }

  /**
   * Health check method called by MCP registry
   */
  async healthCheck(): Promise<boolean> {
    try {
      // Simulate API health check
      const response = await this.makeRequest('GET', '/rate_limit');
      this.lastHealthCheck = new Date();
      return response !== null;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get repository information
   */
  async getRepository(owner: string, repo: string): Promise<any> {
    return this.makeRequest('GET', `/repos/${owner}/${repo}`);
  }

  /**
   * List repository issues
   */
  async getIssues(owner: string, repo: string, options: any = {}): Promise<any[]> {
    const params = new URLSearchParams(options);
    return this.makeRequest('GET', `/repos/${owner}/${repo}/issues?${params}`);
  }

  /**
   * Create a new issue
   */
  async createIssue(owner: string, repo: string, issue: {
    title: string;
    body?: string;
    labels?: string[];
    assignees?: string[];
  }): Promise<any> {
    return this.makeRequest('POST', `/repos/${owner}/${repo}/issues`, issue);
  }

  /**
   * List pull requests
   */
  async getPullRequests(owner: string, repo: string, options: any = {}): Promise<any[]> {
    const params = new URLSearchParams(options);
    return this.makeRequest('GET', `/repos/${owner}/${repo}/pulls?${params}`);
  }

  /**
   * Auto-adapt as JRVI logic agent
   * This method demonstrates how MCPs can be adapted as logic agents
   */
  async adaptAsJRVIAgent(): Promise<{
    capabilities: string[];
    methods: string[];
    description: string;
  }> {
    return {
      capabilities: [
        'repository_management',
        'issue_tracking',
        'pull_request_management',
        'collaborative_development'
      ],
      methods: [
        'getRepository',
        'getIssues',
        'createIssue',
        'getPullRequests',
        'analyzeCodebase',
        'generateProjectReport'
      ],
      description: 'GitHub integration agent for repository management and collaborative development workflows'
    };
  }

  /**
   * Advanced method: Analyze codebase
   */
  async analyzeCodebase(owner: string, repo: string): Promise<{
    languages: Record<string, number>;
    contributors: number;
    issues: { open: number; closed: number };
    lastActivity: string;
  }> {
    try {
      const [repoData, languages, contributors, issues] = await Promise.all([
        this.getRepository(owner, repo),
        this.makeRequest('GET', `/repos/${owner}/${repo}/languages`),
        this.makeRequest('GET', `/repos/${owner}/${repo}/contributors`),
        this.getIssues(owner, repo, { state: 'all' })
      ]);

      return {
        languages: languages || {},
        contributors: Array.isArray(contributors) ? contributors.length : 0,
        issues: {
          open: issues.filter(issue => issue.state === 'open').length,
          closed: issues.filter(issue => issue.state === 'closed').length
        },
        lastActivity: repoData?.updated_at || new Date().toISOString()
      };
    } catch (error) {
      throw new Error(`Failed to analyze codebase: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Generate project report
   */
  async generateProjectReport(owner: string, repo: string): Promise<string> {
    try {
      const analysis = await this.analyzeCodebase(owner, repo);
      const repoData = await this.getRepository(owner, repo);

      return `
# Project Report: ${repoData.full_name}

## Overview
- **Description**: ${repoData.description || 'No description available'}
- **Language**: ${repoData.language || 'Not specified'}
- **Stars**: ${repoData.stargazers_count || 0}
- **Forks**: ${repoData.forks_count || 0}
- **Last Updated**: ${new Date(analysis.lastActivity).toLocaleDateString()}

## Code Analysis
- **Languages**: ${Object.keys(analysis.languages).join(', ')}
- **Contributors**: ${analysis.contributors}
- **Issues**: ${analysis.issues.open} open, ${analysis.issues.closed} closed

## Health Status
- **Active Development**: ${new Date(analysis.lastActivity) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) ? 'Yes' : 'No'}
- **Community Engagement**: ${analysis.issues.open > 0 ? 'Active' : 'Low'}

---
Generated by JRVI GitHub MCP on ${new Date().toLocaleString()}
      `.trim();
    } catch (error) {
      return `Error generating report: ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  }

  /**
   * Make API request with rate limiting and error handling
   */
  private async makeRequest(method: string, endpoint: string, data?: any): Promise<any> {
    // Check rate limit
    if (this.config.rateLimit.currentUsage >= this.config.rateLimit.requestsPerHour) {
      throw new Error('Rate limit exceeded');
    }

    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 100)); // Simulate network delay
      
      // Update rate limit
      this.config.rateLimit.currentUsage++;

      // Simulate successful response
      switch (endpoint) {
        case '/rate_limit':
          return {
            resources: {
              core: { limit: 5000, remaining: 4999 }
            }
          };
        
        default:
          if (endpoint.includes('/repos/')) {
            return {
              id: 123456,
              full_name: 'example/repo',
              description: 'Example repository for JRVI MCP demonstration',
              language: 'TypeScript',
              stargazers_count: 42,
              forks_count: 7,
              updated_at: new Date().toISOString(),
              state: method === 'GET' && endpoint.includes('/issues') ? 'open' : undefined
            };
          }
          
          return { success: true, method, endpoint, data };
      }
    } catch (error) {
      throw new Error(`GitHub API request failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get current configuration
   */
  getConfig(): GitHubMCPConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<GitHubMCPConfig>): void {
    this.config = { ...this.config, ...updates };
  }

  /**
   * Get MCP metadata for registry
   */
  static getMetadata() {
    return {
      id: 'github_api',
      name: 'GitHub API Wrapper',
      version: '1.0.0',
      description: 'GitHub REST API integration with auto-adaptation for JRVI logic agents',
      type: 'external_api' as const,
      capabilities: [
        'repository_management',
        'issue_tracking', 
        'pull_request_management',
        'codebase_analysis',
        'project_reporting'
      ],
      healthCheckInterval: 300,
      autoDisableOnFailure: true,
      maxFailures: 3
    };
  }
}

export default GitHubMCP;